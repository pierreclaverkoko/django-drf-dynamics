import logging
import time
from typing import Any, Dict, List, Optional, Union

from django.core.cache import cache
from django.core.exceptions import ImproperlyConfigured
from django.db.models import Q, QuerySet
from django.utils.translation import gettext as _
from rest_framework import status
from rest_framework.decorators import action
from rest_framework.response import Response
from rest_framework.serializers import ValidationError

from .autocomplete_backends import DatabaseAutocompleteBackend, ElasticsearchAutocompleteBackend, CacheAutocompleteBackend
from .autocomplete_serializers import AutocompleteItemSerializer, AutocompleteResponseSerializer

logger = logging.getLogger(__name__)


class AdvancedAutocompleteMixin:
    """
    An advanced autocomplete mixin with enhanced search capabilities.
    
    This mixin provides sophisticated autocomplete functionality with:
    - Multi-field search
    - Fuzzy matching
    - Custom ranking/scoring
    - Minimum query length
    - Debouncing support (client-side)
    - Result limiting and pagination
    
    Example usage:
    
    ```python
    class AuthorViewSet(AdvancedAutocompleteMixin, viewsets.ModelViewSet):
        queryset = Author.objects.all()
        autocomplete_fields = ['name', 'email', 'bio']
        autocomplete_min_length = 2
        autocomplete_max_results = 20
        autocomplete_enable_fuzzy = True\n        \n        def get_autocomplete_queryset(self):\n            return self.queryset.select_related('publisher')\n    ```\n    \"\"\"\n    \n    # Autocomplete configuration\n    autocomplete_fields = ['name']  # Fields to search in\n    autocomplete_display_field = None  # Field to display (defaults to first autocomplete field)\n    autocomplete_min_length = 1  # Minimum query length\n    autocomplete_max_results = 50  # Maximum number of results\n    autocomplete_enable_fuzzy = False  # Enable fuzzy matching\n    autocomplete_fuzzy_threshold = 0.6  # Fuzzy matching threshold\n    autocomplete_case_sensitive = False  # Case sensitive search\n    autocomplete_exact_match_boost = 2.0  # Boost factor for exact matches\n    autocomplete_startswith_boost = 1.5  # Boost factor for startswith matches\n    \n    # Backend configuration\n    autocomplete_backend = 'database'  # 'database', 'elasticsearch', 'cache'\n    autocomplete_backends = {\n        'database': DatabaseAutocompleteBackend,\n        'elasticsearch': ElasticsearchAutocompleteBackend,\n        'cache': CacheAutocompleteBackend,\n    }\n    \n    def get_autocomplete_backend(self):\n        \"\"\"\n        Get the configured autocomplete backend.\n        \n        Returns:\n            BaseAutocompleteBackend: Backend instance\n        \"\"\"\n        backend_class = self.autocomplete_backends.get(self.autocomplete_backend)\n        if not backend_class:\n            raise ImproperlyConfigured(f\"Autocomplete backend '{self.autocomplete_backend}' not found\")\n        \n        return backend_class()\n    \n    def get_autocomplete_queryset(self):\n        \"\"\"\n        Get the queryset for autocomplete.\n        \n        Returns:\n            QuerySet: Queryset to search in\n        \"\"\"\n        return self.get_queryset()\n    \n    def get_autocomplete_serializer(self, data, many=True):\n        \"\"\"\n        Get the serializer for autocomplete results.\n        \n        Args:\n            data: Data to serialize\n            many: Whether to serialize multiple objects\n            \n        Returns:\n            Serializer: Configured serializer instance\n        \"\"\"\n        serializer_class = getattr(self, 'autocomplete_serializer_class', AutocompleteItemSerializer)\n        context = self.get_serializer_context() if hasattr(self, 'get_serializer_context') else {}\n        return serializer_class(data, many=many, context=context)\n    \n    @action(detail=False, methods=['get'])\n    def advanced_autocomplete(self, request):\n        \"\"\"\n        Advanced autocomplete endpoint with enhanced search capabilities.\n        \n        Query parameters:\n        - q: Search query (required)\n        - limit: Maximum number of results (default: autocomplete_max_results)\n        - fuzzy: Enable fuzzy matching (default: autocomplete_enable_fuzzy)\n        - fields: Comma-separated list of fields to search in\n        - boost_exact: Boost factor for exact matches\n        - boost_startswith: Boost factor for startswith matches\n        \n        Returns:\n            Response: Autocomplete results with metadata\n        \"\"\"\n        query = request.query_params.get('q', '').strip()\n        \n        # Validate query length\n        if len(query) < self.autocomplete_min_length:\n            return Response({\n                'results': [],\n                'metadata': {\n                    'query': query,\n                    'count': 0,\n                    'min_length': self.autocomplete_min_length,\n                    'message': _(f'Query must be at least {self.autocomplete_min_length} characters long')\n                }\n            })\n        \n        # Parse parameters\n        limit = min(int(request.query_params.get('limit', self.autocomplete_max_results)), self.autocomplete_max_results)\n        enable_fuzzy = request.query_params.get('fuzzy', str(self.autocomplete_enable_fuzzy)).lower() == 'true'\n        search_fields = request.query_params.get('fields', ','.join(self.autocomplete_fields)).split(',')\n        boost_exact = float(request.query_params.get('boost_exact', self.autocomplete_exact_match_boost))\n        boost_startswith = float(request.query_params.get('boost_startswith', self.autocomplete_startswith_boost))\n        \n        # Get backend and perform search\n        backend = self.get_autocomplete_backend()\n        \n        search_config = {\n            'query': query,\n            'fields': search_fields,\n            'limit': limit,\n            'fuzzy': enable_fuzzy,\n            'fuzzy_threshold': self.autocomplete_fuzzy_threshold,\n            'case_sensitive': self.autocomplete_case_sensitive,\n            'boost_exact': boost_exact,\n            'boost_startswith': boost_startswith,\n        }\n        \n        try:\n            start_time = time.time()\n            results = backend.search(\n                queryset=self.get_autocomplete_queryset(),\n                config=search_config,\n                view=self\n            )\n            search_time = (time.time() - start_time) * 1000  # Convert to milliseconds\n            \n            # Serialize results\n            serializer = self.get_autocomplete_serializer(results, many=True)\n            \n            return Response({\n                'results': serializer.data,\n                'metadata': {\n                    'query': query,\n                    'count': len(results),\n                    'limit': limit,\n                    'search_time_ms': round(search_time, 2),\n                    'backend': self.autocomplete_backend,\n                    'fuzzy_enabled': enable_fuzzy,\n                    'fields_searched': search_fields\n                }\n            })\n            \n        except Exception as e:\n            logger.error(f\"Autocomplete search error: {e}\")\n            return Response(\n                {'error': _('Search failed'), 'details': str(e)},\n                status=status.HTTP_500_INTERNAL_SERVER_ERROR\n            )\n    \n    @action(detail=False, methods=['get'])\n    def autocomplete_config(self, request):\n        \"\"\"\n        Get autocomplete configuration for frontend.\n        \n        Returns:\n            Response: Autocomplete configuration\n        \"\"\"\n        return Response({\n            'fields': self.autocomplete_fields,\n            'display_field': self.autocomplete_display_field or self.autocomplete_fields[0],\n            'min_length': self.autocomplete_min_length,\n            'max_results': self.autocomplete_max_results,\n            'fuzzy_enabled': self.autocomplete_enable_fuzzy,\n            'fuzzy_threshold': self.autocomplete_fuzzy_threshold,\n            'case_sensitive': self.autocomplete_case_sensitive,\n            'backend': self.autocomplete_backend,\n            'endpoints': {\n                'search': f\"{request.build_absolute_uri()}advanced_autocomplete/\",\n                'config': f\"{request.build_absolute_uri()}autocomplete_config/\"\n            },\n            'debounce_recommended_ms': 300,  # Recommended frontend debouncing\n            'example_usage': {\n                'basic': f\"{request.build_absolute_uri()}advanced_autocomplete/?q=search_term\",\n                'limited': f\"{request.build_absolute_uri()}advanced_autocomplete/?q=term&limit=10\",\n                'fuzzy': f\"{request.build_absolute_uri()}advanced_autocomplete/?q=term&fuzzy=true\"\n            }\n        })\n\n\nclass CachedAutocompleteMixin(AdvancedAutocompleteMixin):\n    \"\"\"\n    Autocomplete mixin with intelligent caching.\n    \n    This mixin adds caching capabilities to autocomplete searches,\n    significantly improving performance for repeated queries.\n    \n    Example usage:\n    \n    ```python\n    class ProductViewSet(CachedAutocompleteMixin, viewsets.ModelViewSet):\n        queryset = Product.objects.all()\n        autocomplete_cache_timeout = 900  # 15 minutes\n        autocomplete_cache_key_prefix = 'product_autocomplete'\n        autocomplete_cache_by_user = True\n    ```\n    \"\"\"\n    \n    # Cache configuration\n    autocomplete_cache_timeout = 600  # 10 minutes\n    autocomplete_cache_key_prefix = 'autocomplete'\n    autocomplete_cache_by_user = False  # Include user ID in cache key\n    autocomplete_cache_vary_by = []  # Additional parameters to vary cache by\n    \n    def get_autocomplete_cache_key(self, query: str, **kwargs) -> str:\n        \"\"\"\n        Generate cache key for autocomplete query.\n        \n        Args:\n            query: Search query\n            **kwargs: Additional parameters\n            \n        Returns:\n            str: Cache key\n        \"\"\"\n        model_name = self.get_queryset().model._meta.label_lower\n        \n        # Base key components\n        key_parts = [\n            self.autocomplete_cache_key_prefix,\n            model_name,\n            query.lower()[:50]  # Limit query length in cache key\n        ]\n        \n        # Add user ID if enabled\n        if self.autocomplete_cache_by_user and hasattr(self, 'request'):\n            user_id = getattr(self.request.user, 'id', 'anon') if self.request.user.is_authenticated else 'anon'\n            key_parts.append(str(user_id))\n        \n        # Add custom vary-by parameters\n        for param in self.autocomplete_cache_vary_by:\n            value = kwargs.get(param, '')\n            key_parts.append(f\"{param}:{value}\")\n        \n        # Add search configuration to cache key\n        config_hash = hash(str(sorted(kwargs.items())))\n        key_parts.append(str(abs(config_hash)))\n        \n        return ':'.join(key_parts)\n    \n    def get_cached_autocomplete_results(self, cache_key: str) -> Optional[List]:\n        \"\"\"\n        Retrieve cached autocomplete results.\n        \n        Args:\n            cache_key: Cache key\n            \n        Returns:\n            Optional[List]: Cached results or None\n        \"\"\"\n        return cache.get(cache_key)\n    \n    def set_cached_autocomplete_results(self, cache_key: str, results: List) -> None:\n        \"\"\"\n        Cache autocomplete results.\n        \n        Args:\n            cache_key: Cache key\n            results: Results to cache\n        \"\"\"\n        cache.set(cache_key, results, timeout=self.autocomplete_cache_timeout)\n    \n    def invalidate_autocomplete_cache(self, pattern: str = None) -> None:\n        \"\"\"\n        Invalidate autocomplete cache entries.\n        \n        Args:\n            pattern: Cache key pattern to match (optional)\n        \"\"\"\n        if pattern:\n            # This would require a more sophisticated cache backend\n            # that supports pattern-based deletion\n            logger.info(f\"Cache invalidation requested for pattern: {pattern}\")\n        else:\n            # Clear all cache entries for this model\n            model_name = self.get_queryset().model._meta.label_lower\n            pattern = f\"{self.autocomplete_cache_key_prefix}:{model_name}:*\"\n            logger.info(f\"Cache invalidation requested for pattern: {pattern}\")\n    \n    @action(detail=False, methods=['get'])\n    def advanced_autocomplete(self, request):\n        \"\"\"\n        Override to add caching functionality.\n        \"\"\"\n        query = request.query_params.get('q', '').strip()\n        \n        if len(query) < self.autocomplete_min_length:\n            return super().advanced_autocomplete(request)\n        \n        # Generate cache key\n        cache_params = {\n            'limit': request.query_params.get('limit', self.autocomplete_max_results),\n            'fuzzy': request.query_params.get('fuzzy', str(self.autocomplete_enable_fuzzy)),\n            'fields': request.query_params.get('fields', ','.join(self.autocomplete_fields)),\n        }\n        cache_key = self.get_autocomplete_cache_key(query, **cache_params)\n        \n        # Check cache first\n        cached_results = self.get_cached_autocomplete_results(cache_key)\n        if cached_results is not None:\n            return Response({\n                'results': cached_results,\n                'metadata': {\n                    'query': query,\n                    'count': len(cached_results),\n                    'cached': True,\n                    'cache_key': cache_key[:50] + '...' if len(cache_key) > 50 else cache_key\n                }\n            })\n        \n        # Get fresh results\n        response = super().advanced_autocomplete(request)\n        \n        # Cache the results if successful\n        if response.status_code == 200 and 'results' in response.data:\n            self.set_cached_autocomplete_results(cache_key, response.data['results'])\n            response.data['metadata']['cached'] = False\n            response.data['metadata']['cache_timeout'] = self.autocomplete_cache_timeout\n        \n        return response\n    \n    def perform_create(self, serializer):\n        \"\"\"\n        Override to invalidate cache on create.\n        \"\"\"\n        instance = serializer.save()\n        self.invalidate_autocomplete_cache()\n        return instance\n    \n    def perform_update(self, serializer):\n        \"\"\"\n        Override to invalidate cache on update.\n        \"\"\"\n        instance = serializer.save()\n        self.invalidate_autocomplete_cache()\n        return instance\n    \n    def perform_destroy(self, instance):\n        \"\"\"\n        Override to invalidate cache on delete.\n        \"\"\"\n        self.invalidate_autocomplete_cache()\n        instance.delete()\n\n\nclass MultiFieldAutocompleteMixin(AdvancedAutocompleteMixin):\n    \"\"\"\n    Autocomplete mixin with multi-field search configuration.\n    \n    This mixin allows for different search configurations for different\n    fields, including field-specific weights and search types.\n    \n    Example usage:\n    \n    ```python\n    class ContactViewSet(MultiFieldAutocompleteMixin, viewsets.ModelViewSet):\n        queryset = Contact.objects.all()\n        autocomplete_field_config = {\n            'name': {\n                'weight': 2.0,\n                'search_type': 'icontains',\n                'boost_exact': 3.0\n            },\n            'email': {\n                'weight': 1.5,\n                'search_type': 'istartswith',\n                'boost_exact': 2.0\n            },\n            'phone': {\n                'weight': 1.0,\n                'search_type': 'exact',\n                'fuzzy': False\n            }\n        }\n    ```\n    \"\"\"\n    \n    autocomplete_field_config = {}  # Field-specific configuration\n    \n    def get_field_search_config(self, field_name: str) -> Dict[str, Any]:\n        \"\"\"\n        Get search configuration for a specific field.\n        \n        Args:\n            field_name: Name of the field\n            \n        Returns:\n            Dict[str, Any]: Field configuration\n        \"\"\"\n        default_config = {\n            'weight': 1.0,\n            'search_type': 'icontains',\n            'boost_exact': self.autocomplete_exact_match_boost,\n            'boost_startswith': self.autocomplete_startswith_boost,\n            'fuzzy': self.autocomplete_enable_fuzzy,\n            'case_sensitive': self.autocomplete_case_sensitive\n        }\n        \n        field_config = self.autocomplete_field_config.get(field_name, {})\n        default_config.update(field_config)\n        \n        return default_config\n    \n    def get_weighted_search_query(self, query: str, fields: List[str]) -> Q:\n        \"\"\"\n        Build a weighted search query across multiple fields.\n        \n        Args:\n            query: Search query\n            fields: List of fields to search\n            \n        Returns:\n            Q: Django Q object for the search\n        \"\"\"\n        search_q = Q()\n        \n        for field in fields:\n            field_config = self.get_field_search_config(field)\n            search_type = field_config['search_type']\n            \n            # Build field-specific query\n            field_q = Q(**{f\"{field}__{search_type}\": query})\n            \n            # Add exact match boost if configured\n            if field_config.get('boost_exact', 0) > 1 and search_type != 'exact':\n                exact_q = Q(**{f\"{field}__iexact\": query})\n                field_q = field_q | exact_q\n            \n            # Add startswith boost if configured\n            if field_config.get('boost_startswith', 0) > 1 and search_type not in ['exact', 'istartswith']:\n                startswith_q = Q(**{f\"{field}__istartswith\": query})\n                field_q = field_q | startswith_q\n            \n            search_q |= field_q\n        \n        return search_q\n    \n    @action(detail=False, methods=['get'])\n    def field_config(self, request):\n        \"\"\"\n        Get field configuration for autocomplete.\n        \n        Returns:\n            Response: Field configuration details\n        \"\"\"\n        field_configs = {}\n        \n        for field in self.autocomplete_fields:\n            field_configs[field] = self.get_field_search_config(field)\n        \n        return Response({\n            'fields': field_configs,\n            'default_config': {\n                'weight': 1.0,\n                'search_type': 'icontains',\n                'boost_exact': self.autocomplete_exact_match_boost,\n                'boost_startswith': self.autocomplete_startswith_boost,\n                'fuzzy': self.autocomplete_enable_fuzzy,\n                'case_sensitive': self.autocomplete_case_sensitive\n            }\n        })\n\n\nclass NestedLookupMixin:\n    \"\"\"\n    Mixin for handling nested object lookups with relationship traversal.\n    \n    This mixin extends lookup functionality to search across related models\n    and provides nested object information in responses.\n    \n    Example usage:\n    \n    ```python\n    class OrderViewSet(NestedLookupMixin, viewsets.ModelViewSet):\n        queryset = Order.objects.all()\n        nested_lookup_fields = {\n            'customer': {\n                'model': 'Customer',\n                'fields': ['name', 'email'],\n                'display_format': '{name} ({email})'\n            },\n            'product': {\n                'model': 'Product',\n                'fields': ['name', 'sku'],\n                'display_format': '{name} - {sku}'\n            }\n        }\n    ```\n    \"\"\"\n    \n    nested_lookup_fields = {}  # Configuration for nested lookups\n    nested_lookup_max_depth = 3  # Maximum relationship depth\n    \n    def get_nested_lookup_config(self, field_name: str) -> Dict[str, Any]:\n        \"\"\"\n        Get configuration for nested lookup field.\n        \n        Args:\n            field_name: Name of the nested field\n            \n        Returns:\n            Dict[str, Any]: Nested field configuration\n        \"\"\"\n        return self.nested_lookup_fields.get(field_name, {})\n    \n    def perform_nested_lookup(self, field_name: str, query: str) -> QuerySet:\n        \"\"\"\n        Perform lookup on nested/related fields.\n        \n        Args:\n            field_name: Name of the field to lookup\n            query: Search query\n            \n        Returns:\n            QuerySet: Results from nested lookup\n        \"\"\"\n        config = self.get_nested_lookup_config(field_name)\n        \n        if not config:\n            return self.get_queryset().none()\n        \n        search_fields = config.get('fields', [])\n        queryset = self.get_queryset()\n        \n        # Build nested search query\n        search_q = Q()\n        for search_field in search_fields:\n            nested_field = f\"{field_name}__{search_field}__icontains\"\n            search_q |= Q(**{nested_field: query})\n        \n        return queryset.filter(search_q).select_related(field_name)\n    \n    def format_nested_display(self, obj, field_name: str) -> str:\n        \"\"\"\n        Format display string for nested object.\n        \n        Args:\n            obj: The main object\n            field_name: Name of the nested field\n            \n        Returns:\n            str: Formatted display string\n        \"\"\"\n        config = self.get_nested_lookup_config(field_name)\n        display_format = config.get('display_format', '{}')\n        \n        nested_obj = getattr(obj, field_name, None)\n        if not nested_obj:\n            return ''\n        \n        # Extract field values for formatting\n        format_values = {}\n        for field in config.get('fields', []):\n            format_values[field] = getattr(nested_obj, field, '')\n        \n        try:\n            return display_format.format(**format_values)\n        except (KeyError, ValueError):\n            return str(nested_obj)\n    \n    @action(detail=False, methods=['get'])\n    def nested_autocomplete(self, request):\n        \"\"\"\n        Perform autocomplete search across nested/related fields.\n        \n        Query parameters:\n        - q: Search query\n        - field: Nested field to search in\n        - limit: Maximum results\n        \n        Returns:\n            Response: Nested autocomplete results\n        \"\"\"\n        query = request.query_params.get('q', '').strip()\n        field_name = request.query_params.get('field', '')\n        limit = int(request.query_params.get('limit', 20))\n        \n        if not query or not field_name:\n            return Response({\n                'results': [],\n                'metadata': {\n                    'error': 'Both q and field parameters are required'\n                }\n            })\n        \n        if field_name not in self.nested_lookup_fields:\n            return Response({\n                'results': [],\n                'metadata': {\n                    'error': f'Field {field_name} not configured for nested lookup'\n                }\n            })\n        \n        # Perform nested search\n        try:\n            queryset = self.perform_nested_lookup(field_name, query)[:limit]\n            \n            # Format results\n            results = []\n            for obj in queryset:\n                nested_display = self.format_nested_display(obj, field_name)\n                results.append({\n                    'id': obj.id,\n                    'text': str(obj),\n                    'nested_display': nested_display,\n                    'field': field_name\n                })\n            \n            return Response({\n                'results': results,\n                'metadata': {\n                    'query': query,\n                    'field': field_name,\n                    'count': len(results),\n                    'limit': limit\n                }\n            })\n            \n        except Exception as e:\n            logger.error(f\"Nested lookup error: {e}\")\n            return Response(\n                {'error': _('Nested lookup failed'), 'details': str(e)},\n                status=status.HTTP_500_INTERNAL_SERVER_ERROR\n            )\n    \n    @action(detail=False, methods=['get'])\n    def nested_lookup_config(self, request):\n        \"\"\"\n        Get configuration for nested lookups.\n        \n        Returns:\n            Response: Nested lookup configuration\n        \"\"\"\n        return Response({\n            'nested_fields': self.nested_lookup_fields,\n            'max_depth': self.nested_lookup_max_depth,\n            'endpoints': {\n                'nested_search': f\"{request.build_absolute_uri()}nested_autocomplete/\",\n                'config': f\"{request.build_absolute_uri()}nested_lookup_config/\"\n            }\n        })